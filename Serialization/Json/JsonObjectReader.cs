#region License
// Copyright (c) 2014, David Taylor
//
// Permission to use, copy, modify, and/or distribute this software for any 
// purpose with or without fee is hereby granted, provided that the above 
// copyright notice and this permission notice appear in all copies, unless 
// such copies are solely in the form of machine-executable object code 
// generated by a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES 
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF 
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR 
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES 
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN 
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF 
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#endregion License
using System;
using System.Globalization;
using System.IO;
using System.Text;

namespace HotChai.Serialization.Json
{
    public sealed class JsonObjectReader : ObjectReader
    {
        private BinaryReader _reader;
        private InspectorStream _stream;
        private StringBuilder _stringBuilder = new StringBuilder();
        private string _token;
        private bool _peekingToken;
        private char _peekChar;
        private bool _peekingChar;

        // Buffers to support the workaround for reading UTF8 characters
        // that cannot be encoded as a single .NET char
        private byte[] _utf8Buffer = new byte[6];
        private char[] _charBuffer = new char[2];

        private static readonly uint[] HexValue = new uint[]
        {
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 00 - 0f
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 10 - 1f
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20 - 2f
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, // 30 - 3f
            0, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 40 - 4f
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 50 - 5f
            0, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 60 - 6f
        };

        public JsonObjectReader(
            Stream stream)
        {
            if (null == stream)
            {
                throw new ArgumentNullException("stream");
            }

            this._stream = new InspectorStream(stream);
            this._reader = new BinaryReader(stream, Encoding.UTF8);
        }

        public override ISerializationInspector Inspector
        {
            get
            {
                return this._stream.Inspector;
            }

            set
            {
                this._stream.Inspector = value;
            }
        }

        protected override bool ReadStartObjectToken()
        {
            string token = ReadToken();
            if (token == JsonToken.StartObject)
            {
                return true;
            }
            else if (token == JsonToken.Null)
            {
                return false;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }

        protected override bool ReadNextObjectMemberKey()
        {
            string token = PeekToken();

            if (token == JsonToken.EndObject)
            {
                return false;
            }
            else if (token == JsonToken.Comma)
            {
                ReadComma();
            }

            string memberName = ReadString(20);

            this.MemberKey = int.Parse(memberName, CultureInfo.InvariantCulture);

            ReadColon();

            return true;
        }

        protected override void ReadEndObjectToken()
        {
            ReadToken(JsonToken.EndObject);
        }

        protected override bool ReadStartArrayToken()
        {
            string token = ReadToken();
            if (token == JsonToken.StartArray)
            {
                return true;
            }
            else if (token == JsonToken.Null)
            {
                return false;
            }
            else
            {
                throw new InvalidOperationException();
            }
        }

        protected override bool ReadToFirstArrayValue()
        {
            string token = PeekToken();
            if (token == JsonToken.EndArray)
            {
                return false;
            }

            return true;
        }

        protected override bool ReadToNextArrayValue()
        {
            string token = PeekToken();
            if (token == JsonToken.EndArray)
            {
                return false;
            }
            else if (token != JsonToken.Comma)
            {
                throw new InvalidOperationException();
            }

            ReadComma();

            return true;
        }

        protected override void ReadEndArrayToken()
        {
            ReadToken(JsonToken.EndArray);
        }

        protected override bool ReadPrimitiveValueAsBoolean()
        {
            SkipWhiteSpace();

            string token = ReadToken();

            if (token == JsonToken.True)
            {
                return true;
            }
            else if (token == JsonToken.False)
            {
                return false;
            }
            else
            {
                throw new InvalidOperationException("Unexpected Boolean value");
            }
        }

        protected override int ReadPrimitiveValueAsInt32()
        {
            string number = ReadNumber();

            return int.Parse(number, CultureInfo.InvariantCulture);
        }

        protected override uint ReadPrimitiveValueAsUInt32()
        {
            string number = ReadNumber();

            return uint.Parse(number, CultureInfo.InvariantCulture);
        }

        protected override long ReadPrimitiveValueAsInt64()
        {
            string number = ReadNumber();

            return long.Parse(number, CultureInfo.InvariantCulture);
        }

        protected override ulong ReadPrimitiveValueAsUInt64()
        {
            string number = ReadNumber();

            return ulong.Parse(number, CultureInfo.InvariantCulture);
        }

        protected override float ReadPrimitiveValueAsSingle()
        {
            string number = ReadNumber();

            return float.Parse(number, CultureInfo.InvariantCulture);
        }

        protected override double ReadPrimitiveValueAsDouble()
        {
            string number = ReadNumber();

            return double.Parse(number, CultureInfo.InvariantCulture);
        }

        protected override byte[] ReadPrimitiveValueAsBytes(
            int byteQuota)
        {
            // NOTE: Increase quota to account for Base64 expansion
            string base64 = ReadString(byteQuota * 4 / 3 + 2);
            if (base64 == null)
            {
                return null;
            }

            return Convert.FromBase64String(base64);
        }

        protected override string ReadPrimitiveValueAsString(
            int byteQuota)
        {
            return ReadString(Encoding.UTF8.GetMaxCharCount(byteQuota));
        }

        protected override MemberValueType PeekValueType()
        {
            string token = PeekToken();

            if (token == JsonToken.StartObject)
            {
                return MemberValueType.Object;
            }
            else if (token == JsonToken.StartArray)
            {
                return MemberValueType.Array;
            }

            return MemberValueType.Primitive;
        }

        protected override void SkipPrimitiveValue()
        {
            string token = PeekToken();

            if (token == JsonToken.True)
            {
                ReadToken();
            }
            else if (token == JsonToken.False)
            {
                ReadToken();
            }
            else if (token == JsonToken.Null)
            {
                ReadToken();
            }
            else
            {
                char separator = PeekChar();
                if (separator == '"')
                {
                    SkipString();
                }
                else
                {
                    SkipNumber();
                }
            }
        }

        private void SkipWhiteSpace()
        {
            //char c;
            //do
            //{
            //    c = PeekChar();
            //    if (!IsWhiteSpace(c))
            //    {
            //        break;
            //    }

            //    c = ReadChar();
            //}
            //while (true);
        }

        private string ReadToken()
        {
            if (this._peekingToken)
            {
                this._peekingToken = false;
                return this._token;
            }

            SkipWhiteSpace();

            string token;

            char c;

            c = PeekChar();

            if (c == '{')
            {
                ReadChar();
                token = JsonToken.StartObject;
            }
            else if (c == '}')
            {
                ReadChar();
                token = JsonToken.EndObject;
            }
            else if (c == '[')
            {
                ReadChar();
                token = JsonToken.StartArray;
            }
            else if (c == ']')
            {
                ReadChar();
                token = JsonToken.EndArray;
            }
            else if (c == ':')
            {
                ReadChar();
                token = JsonToken.Colon;
            }
            else if (c == ',')
            {
                ReadChar();
                token = JsonToken.Comma;
            }
            else if (c == 'n')
            {
                // TODO: Validate
                ReadChar();
                ReadChar();
                ReadChar();
                ReadChar();

                token = JsonToken.Null;
            }
            else if (c == 't')
            {
                // TODO: Validate
                ReadChar();
                ReadChar();
                ReadChar();
                ReadChar();

                token = JsonToken.True;
            }
            else if (c == 'f')
            {
                // TODO: Validate
                ReadChar();
                ReadChar();
                ReadChar();
                ReadChar();
                ReadChar();

                token = JsonToken.False;
            }
            else
            {
                token = null;
            }

            this._token = token;

            return token;
        }

        private bool IsWhiteSpace(char c)
        {
            return ((c == ' ') || (c == '\u0009') || (c == '\u000a') || (c == '\u000d'));
        }

        private bool IsNumeric(char c)
        {
            return (((c >= '0') && (c <= '9')) || (c == '+') || (c == '-') || (c == '.') || (c == 'e') || (c == 'E'));
        }

        private void ReadToken(string token)
        {
            string readToken = ReadToken();
            if (readToken != token)
            {
                throw new InvalidOperationException("Unexpected token");
            }
        }

        private string PeekToken()
        {
            if (!this._peekingToken)
            {
                if (null != ReadToken())
                {
                    this._peekingToken = true;
                }
            }

            return this._token;
        }

        private void ReadColon()
        {
            ReadToken(JsonToken.Colon);
        }

        private void ReadComma()
        {
            ReadToken(JsonToken.Comma);
        }

        private string ReadString(
            int charQuota)
        {
            SkipWhiteSpace();

            this._stringBuilder.Length = 0;

            char c = ReadChar();

            // null
            if (c == 'n')
            {
                // TODO: Validate
                ReadChar();
                ReadChar();
                ReadChar();

                return null;
            }

            // Opening double quote
            if (c != '"')
            {
                throw new InvalidOperationException();
            }

            int charCount;

            do
            {
                charCount = ReadUtf8Character(this._charBuffer);
                if (charCount > 1)
                {
                    // Surrogate pair
                    this._stringBuilder.Append(this._charBuffer, 0, charCount);
                    continue;
                }

                c = this._charBuffer[0];

                if (c == '\"')
                {
                    // Ending double quote

                    break;
                }
                else if (c == '\\')
                {
                    // Escape sequence

                    c = ReadChar();

                    if (c == '"')
                    {
                        this._stringBuilder.Append('\"');
                    }
                    else if (c == '\\')
                    {
                        this._stringBuilder.Append('\\');
                    }
                    else if (c == 'b')
                    {
                        this._stringBuilder.Append((char)0x8);
                    }
                    else if (c == 'f')
                    {
                        this._stringBuilder.Append((char)0xc);
                    }
                    else if (c == 'n')
                    {
                        this._stringBuilder.Append((char)0xa);
                    }
                    else if (c == 'r')
                    {
                        this._stringBuilder.Append((char)0xd);
                    }
                    else if (c == 't')
                    {
                        this._stringBuilder.Append((char)0x9);
                    }
                    else if (c == 'u')
                    {
                        uint hexValue = HexValue[ReadChar()];
                        hexValue += (hexValue * 0x10) + HexValue[ReadChar()];
                        hexValue += (hexValue * 0x10) + HexValue[ReadChar()];
                        hexValue += (hexValue * 0x10) + HexValue[ReadChar()];
                        this._stringBuilder.Append((char)hexValue);
                    }
                    else
                    {
                        throw new InvalidOperationException();
                    }
                }
                else
                {
                    this._stringBuilder.Append(c);
                }
            }
            while (this._stringBuilder.Length < charQuota);

            if (this._stringBuilder.Length >= charQuota)
            {
                throw new InvalidOperationException("Exceeded quota.");
            }

            return this._stringBuilder.ToString();
        }

        private string ReadNumber()
        {
            SkipWhiteSpace();

            this._stringBuilder.Length = 0;

            char c;
            do
            {
                c = PeekChar();
                if (!IsNumeric(c))
                {
                    break;
                }

                this._stringBuilder.Append(c);
                ReadChar();
            }
            while (true);

            return this._stringBuilder.ToString();
        }

        private void SkipNumber()
        {
            ReadNumber();
        }

        private void SkipString()
        {
            // TODO: Efficient skipping
            ReadString(1024 * 1024);
        }

        private char PeekChar()
        {
            if (!this._peekingChar)
            {
                this._peekChar = this._reader.ReadChar();
                this._peekingChar = true;
            }

            return this._peekChar;
        }

        private char ReadChar()
        {
            if (this._peekingChar)
            {
                this._peekingChar = false;
                return this._peekChar;
            }

            return this._reader.ReadChar();
        }

        // NOTE: This is a workaround for the problem where BinaryReader
        // throws an exception when attempting to read a UTF-8 encoded 
        // character that requires more than one Char to represent 
        // (e.g., a surrogate pair).
        private int ReadUtf8Character(
            char[] charBuffer)
        {
            byte lengthByte = this._reader.ReadByte();
            charBuffer[0] = (char)lengthByte;

            if (lengthByte < 0x80)
            {
                return 1;
            }

            this._utf8Buffer[0] = lengthByte;
            lengthByte <<= 1;

            int i = 1;

            while ((lengthByte & 0x80) == 0x80)
            {
                this._utf8Buffer[i] = this._reader.ReadByte();
                i += 1;

                lengthByte <<= 1;
            };

            return Encoding.UTF8.GetChars(this._utf8Buffer, 0, i, charBuffer, 0);
        }
    }
}
